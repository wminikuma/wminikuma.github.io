---
title: "[Go] Slice 살펴보기"
date: 2024-10-07 10:11:00 +0900
categories: [IT, Golang]
tags: [golang, slice]     # TAG names should always be lowercase
---     

동적 배열인 슬라이스의 동작을 살펴보자.    

## **16.1 슬라이스**      
---
슬라이스를 선언하고 요소에 접근, 순회 및 요소를 추가하는 방법을 알아보자.     

### **16.1.1 슬라이스 선언**    
---  
```go
var array [10]int
```     
위 코드와 같이 다음과 같은 ```array```는 ```10```이라는 고정 길이를 가지고 있다. 고정 길이를 가지고 있다는 거는 10개 보다 많은 값을 저장할 수 없음을 의미한다. 만약 고정값(```10```)보다 더 많은 값을 저장하기 위해서는 더 큰 배열을 만들어서 더 큰 배열에 값을 복사하는 방법을 선택해야 한다.       

하지만 슬라이스를 사용하게 되면 조금 더 쉽게 값을 다룰 수 있게 된다. 그렇다면 어떻게 쉽게 다룰 수 있는 지 알아보자.     

```go
var slice []int
```      
위와 같이 선언된 슬라이스를 별도로 초기화 하지 않는다면 크기가 ```0```인 슬라이스가 만들어 지고, 슬라이스 길이를 초과하게 되면 에러가 발생한다. 초기화는 필요하다.     

```go
package main

import "fmt"

func main() {
    var slice []int // 슬라이스 선언 후 별도의 초기화 작업을 하지 않음

    if (len(slice) == 0) {
        fmt.Println("slice is empty", slice)
    }

    slice[1] = 10  //패닉 발생: 할당되지 않은 메모리에 접근하는 상태
    fmt.Println("slice")
}
```      

```text
slice is empty []
panic: runtime error: index out of range [1] with length 0

goroutine 1 [running]:
main.main()
        /Users/jihoonjeon/must/golang-study/ch16_slice/cmd/main.go:12 +0x84
exit status 2
```     

초기화는 2가지 방법이 있다.     


**1) ```{}```를 이용하여 초기화 하기**      

배열처럼 ```{}```(중괄호)를 사용하여 초기화 하는 방법이다.

```go
var slice1 = []int{1, 2, 3}
var slice2 = []int{1, 5: 2, 10: 3}  // 5의 인덱스 값 = 2, 10의 인덱스 값 = 3
```    

```text
slice1:  [1 2 3]
slice2:  [1 0 0 0 0 2 0 0 0 0 3]
```      

**2) ```make```를 이용하여 초기화 하기**     

```make()```내장 함수를 이용하는 방법이다. 아래 코드는 정의된 ```make()```이다.

```go
func make(t Type, size ...IntegerType) Type
```    

(사용예시)
```go
var slice = make([]int, 3)
```      

(결과)
```text
slice:  [0 0 0]   // 타입의 기본값 = 0
```     

### **16.1.2 슬라이스 요소 접근**    
---       

슬라이스에 접근하는 방법은 배열과 똑같다.      

```go
var slice = make([]int, 3)
slice[1] = 5     // 슬라이스의 1번 인덱스의 값을 5로 변경
```       

### **16.1.3 슬라이스 요소 순회**    
---     

슬라이스 값 또한 배열과 유사하게 순회한다. 하지만 동적으로 크기가 늘어나는 점만 다르다. 나머지는 배열의 사용법과 같다.    

```go
var slice = []int{1, 2, 3}

for i := 0; i < len(slice); i++ {
    slice[i] += 10
}

fmt.Println("(1) slice : ", slice)

for i, v := range slice {   // 첫번 째 i는 인덱스, 두번 째 v는 값
    slice[i] = v * 2
}

fmt.Println("(2) slice : ", slice)
```     

```text
(1) slice :  [11 12 13]
(2) slice :  [22 24 26]
```

### **16.1.4 슬라이스 요소 추가-```append()```**    
---      

> **(생각)** 슬라이스의 고유의 기능이다. 슬라이스는 배열과 다르게 동적으로 크기를 늘릴 수 있다고 하였다. ```append()```를 사용하여 선언된 크기보다 더 큰 요소를 추가할 수 있다. 여기서 중요한 점은 새로운 슬라이스를 만든다는 점이다.
{: .prompt-info }      

```go
var slice1 = []int{1, 2, 3}
fmt.Println("slice 1의 주소값, 값:", &slice[0], slice)

slice2 := append(slice, 4) // 기존 크기를 늘리고 값을 추가, 새로운 슬라이스를 반환
fmt.Println("slice 2의 주소값, 값:", &slice2[0], slice2)
```      

```text
slice 1의 주소값: 0x1400001a108 [1 2 3]
slice 2의 주소값: 0x14000014180 [1 2 3 4]
```     

### **16.1.5 여러 값 추가하기**    
---       

위에서 확인해 봤듯이 ```append()```를 사용하면 값을 하나를 추가할 수 있고, 그 이상의 값들도 추가가 가능하다.    

```go
var slice = []int{1, 2, 3}  // 3의 크기를 가지고 1, 2, 3 의 값을 가진 슬라이스
fmt.Println("slice 의 주소값, 값:", &slice[0], slice)

slice = append(slice, 4, 5, 6, 7, 8) 
fmt.Println("slice(값 추가) 주소값, 값: ", &slice[0], slice)
```      

```text
slice 의 주소값, 값: 0x14000118018 [1 2 3]
slice(값 추가) 주소값, 값:  0x140001160c0 [1 2 3 4 5 6 7 8]
```    

예제를 보면 첫 번째 인수로 들어온 ```slice```의 값을 변경하는 방식이 아닌 새로운 슬라이스를 만들어서 값을 추가하는 방식으로 동작함을 알 수 있다. 따라서 기존 슬라이스에 값을 추가하고 싶을 때는 ```append()```의 결과를 기존 슬라이스에 대입하여 변경해야 한다.     

## **16.2 슬라이스 동작 원리**      
---     

슬라이스의 내부 동작을 이해하기 위해서는 먼저 내부 구현에서 사용하는 ```SliceHeader``` 구조체를 살펴봐야 한다.       

```go
type SliceHeader struct {
    Data uintptr   // 실제 배열을 가르키는 포인터
    Len  int       // 요소 개수
    Cap  int       // 실제 배열의 크기
}
```      

### **16.2.1 ```make()```함수를 이용한 선언**     
---      

```go
var slice = make([]int, 3)
```         

위 코드에 의해 생성된 슬라이스는 Length가 3이고, Capacity가 3으로 만들어진다. 만약 ```Lengh < Capacity```인 경우는 5의 크기중에 3개만 사용하고 나머지 2개는 나중에 추가될 공간이라 보면 된다.        


### **16.2.2 슬라이스와 배열의 동작 차이**      
---       
   
```go
package main

import "fmt"

func changeArray(array2 [5]int) {
    array2[2] = 200
}

func changeSlice(slice2 [] int) {
    slice2[2] = 200
}

func main() {
    array := [5]int{1, 2, 3, 4, 5}
    slice := []int{1, 2, 3, 4, 5}

    changeArray(array)
    changeSlice(slice)

    fmt.Println("array:", array)
    fmt.Println("slice:", slice)
}
```       

```text
array: [1 2 3 4 5]
slice: [1 2 200 4 5]
```      

여기서 ```slice```는 값이 변경되었지만 ```array```는 변경되지 않은 이유가 무엇일까?      

### **16.2.3 동작 차이의 원인**      
---   

값의 복사? 아니면 값을 가르키고 있는 주소값의 복사?의 차이라고 볼 수 있다.         

> **(생각)** 복사는 새로운 공간에 값을 복사하는 거다. 여기서 값은 포인터, 구조체, 배열, 필드등과 같은 거라 보면 된다.
{: .prompt-info }

Go 언어는 모든 값의 대입(```=```)은 복사로 일어난다. 함수에 인수를 전달하거나 다른 변수에 대입할 때와 같은 값의 이동은 복사로 이루어진다. 복사는 타입의 값의 복사일수도 포인터의 값인 메모리 주소일 수도 있다. 심지어 구조체 복사는 구조체의 모든 필드가 복사된다. 물론 배열의 모든 값도 복사된다.      

* ```changeArray()``` 배열의 크기 = ```40 Bytes```(```5 X 8```) 다른 배열에 값 복사 발생
* ```changeSlice()``` 내부 구조체 (```pointer```, ```len```, ```cap```) = ```24 Bytes``` 구조체 복사 발생      

그렇다면 위 코드의 ```changeArray()```의 값이 변경되지 않고, ```changeSlice()```의 값만 변경된 이유는 무엇일까? 이것은 어떤 값이 복사되었나?로 볼 수 있다. ```changeArray()```는 값이 복사되었다면, ```changeSlice()`는 주솟값이 복사되었다. 결국 어떤 값이 복사되었냐에 따라 다른 결과가 나타날 수 있다. 예를 들어 주솟값의 복사는 복사가 계속 발생한다고 해도 주솟값이 가르키고 있는 값에는 영향을 주지 못하는 거라고 이해하면 된다.        

### **16.2.4 ```append()```를 사용할 때 발생하는 예기치 못한 문제 1**      
---     

위에서 언급한 ```SliceHeader```구조체를 통해 ```append()```동작을 살펴보자.     

* 남은 빈 공간이 있는 지 확인 (```남은 공간 = cap - len```)
* 만약 빈 공간이 추가할 공간보다 크거나 같다면 값을 추가하고 ```len```값을 증가
* 특정 인덱스의 값을 변경하고 싶은 경우, 복사가 일어나지만 주솟값은 동일하기 때문에 값 변경 (같은 실제 배열을 가르키고 있음)      

```go
package main

import "fmt"

func main() {
    slice1 := make([]int, 3, 5)
    // 요소 추가: 4, 5
    slice2 := append(slice1, 4, 5) // len:3, cap:5 슬라이스 만들어짐

    fmt.Println("slice1:", slice1, len(slice1), cap(slice1))
    fmt.Println("slice2:", slice2, len(slice2), cap(slice2))
    // 요소 변경: 1번째 100으로 변경
    slice2[1] = 100 // slice2도 변경

    fmt.Println("After change second element")
    fmt.Println("slice1:", slice1, len(slice1), cap(slice1))
    fmt.Println("slice2:", slice2, len(slice2), cap(slice2))

    // 요소 추가: 500
    slice1 = append(slice1, 500) // slice2도 변경

    fmt.Println("After append 500")
    fmt.Println("slice1:", slice1, len(slice1), cap(slice1))
    fmt.Println("slice2:", slice2, len(slice2), cap(slice2))
}
```      

```text
slice1: [0 0 0] 3 5
slice2: [0 0 0 4 5] 5 5

After change second element
slice1: [0 100 0] 3 5
slice2: [0 100 0 4 5] 5 5

After append 500
slice1: [0 100 0 500] 4 5
slice2: [0 100 0 500 5] 5 5
```

### **16.2.5 ```append()```를 사용할 때 발생하는 예기치 못한 문제 2**      
---     

이제는 빈공간이 없을 때 값을 추가하게 되면 어떻게 되는지 보자.      

* 남은 빈 공간이 있는 지 확인 (```남은 공간 = cap - len```)
* 만약 공간이 충분하지 않으면, 기존 배열의 2배 크기를 가지는 배열을 새로 만든 뒤 기존 값을 복사

> **(중요)** 새로운 공간을 가지는 배열을 만들게 되면 실제 배열 공간도 새로운 크기에 맞게 새롭게 만들어진다.
{: .prompt-info }         

```go
package main

import "fmt"

func main() {
    slice1 := []int{1, 2, 3}       // len:3, cap:3 슬라이스 생성
    slice2 := append(slice1, 4, 5) // 4, 5 요소를 추가 (실제 배열도 2배 크기로 신규 생성)

    fmt.Println("slice1:", slice1, len(slice1), cap(slice1))
    fmt.Println("slice2:", slice2, len(slice2), cap(slice2))

    slice1[1] = 100 // slice1의 요소 값 변경

    fmt.Println("After change second element")
    fmt.Println("slice1:", slice1, len(slice1), cap(slice1))
    fmt.Println("slice2:", slice2, len(slice2), cap(slice2))

    slice1 = append(slice1, 500) // slice1의 값 추가

    fmt.Println("After append 500")
    fmt.Println("slice1:", slice1, len(slice1), cap(slice1))
    fmt.Println("slice2:", slice2, len(slice2), cap(slice2))
}
```         

```text
slice1: [1 2 3] 3 3
slice2: [1 2 3 4 5] 5 6

After change second element
slice1: [1 100 3] 3 3
slice2: [1 2 3 4 5] 5 6   // 실제 배열도 신규로 만들어져 slice1 변경이 slice2에 영향을 주지 않음

After append 500
slice1: [1 100 3 500] 4 6
slice2: [1 2 3 4 5] 5 6   // 실제 배열도 신규로 만들어져 slice1 변경이 slice2에 영향을 주지 않음
```

슬라이스 내부에는 배열을 가르키는 포인터(주솟값)이 있고 ```append()```는 슬라이스가 가르키는 배열에 빈 공간이 충분하다면 추가하고 그렇지 않다면 더 큰 배열을 새로 만들어서 추가한다는 사실을 이해하자.     


## Reference     
---     
* Tucker의 Go 언어 프로그래밍 2판, 공봉식 저
